// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

#include "unixasmmacros.inc"
#include "asmconstants.h"

// EXTERN_C int __fastcall HelperMethodFrameRestoreState(
//         INDEBUG_COMMA(HelperMethodFrame *pFrame)
//         MachState *pState
//         )
LEAF_ENTRY HelperMethodFrameRestoreState, _TEXT
#ifdef _DEBUG
        lgr %r2, %r3
#endif

        // Check if the MachState is valid
        clghsi OFFSETOF__MachState___pRetAddr(%r2), 0
        je SkipRestore

        //
        // If a preserved register were pushed onto the stack between
        // the managed caller and the H_M_F, m_pReg will point to its
        // location on the stack and it would have been updated on the
        // stack by the GC already and it will be popped back into the
        // appropriate register when the appropriate epilog is run.
        //
        // Otherwise, the register is preserved across all the code
        // in this HCALL or FCALL, so we need to update those registers
        // here because the GC will have updated our copies in the
        // frame.
        //
        // So, if m_pReg points into the MachState, we need to update
        // the register here.  That's what this macro does.
        //
#define RestoreReg(reg, regnum) \
        la %r1, (OFFSETOF__MachState__m_Capture + 8 * regnum)(%r2); \
        cg %r1, (OFFSETOF__MachState__m_Ptrs + 8 * regnum)(%r2); \
        jne 0f; \
        lg reg, 0(%r1); \
        0:

        // regnum has to match ENUM_CALLEE_SAVED_REGISTERS macro
        RestoreReg(%r6, 0)
        RestoreReg(%r7, 1)
        RestoreReg(%r8, 2)
        RestoreReg(%r9, 3)
        RestoreReg(%r10, 4)
        RestoreReg(%r11, 5)
        RestoreReg(%r12, 6)
        RestoreReg(%r13, 7)

SkipRestore:
        lghi %r2, 0
        br %r14
LEAF_END HelperMethodFrameRestoreState, _TEXT

//////////////////////////////////////////////////////////////////////////
//
// NDirectImportThunk
//
// In addition to being called by the EE, this function can be called
//  directly from code generated by JIT64 for CRT optimized direct
//  P/Invoke calls. If it is modified, the JIT64 compiler's code
//  generation will need to altered accordingly.
//
// EXTERN_C VOID __stdcall NDirectImportThunk()//
NESTED_ENTRY NDirectImportThunk, _TEXT, NoHandler
        // We need to save argument registers and %r14-%15.
        // For simplicity we just save everything right now.
        stmg %r2, %r15, 16(%r15)
        .cfi_offset 6, -112
        .cfi_offset 7, -104
        .cfi_offset 8, -96
        .cfi_offset 9, -88
        .cfi_offset 10, -80
        .cfi_offset 11, -72
        .cfi_offset 12, -64
        .cfi_offset 13, -56
        .cfi_offset 14, -48
        .cfi_offset 15, -40
        lay %r15, -160(%r15)
        .cfi_def_cfa_offset 320

        // Save floating-point argument registers.
        std %f0, 288(%r15)
        std %f2, 296(%r15)
        std %f4, 304(%r15)
        std %f6, 312(%r15)

        // Call NDirectImportWorker w/ the NDirectMethodDesc*
        lgr %r2, METHODDESC_REGISTER
        brasl %r14, C_FUNC(NDirectImportWorker)

        // Native target adress now in %r2.
        lgr %r1, %r2

        // Restore floating-point argument registers.
        ld %f0, 288(%r15)
        ld %f2, 296(%r15)
        ld %f4, 304(%r15)
        ld %f6, 312(%r15)

        // Restore integer parameter and call-saved registers.
        lmg %r2, %r15, 176(%r15)
        .cfi_restore 15
        .cfi_restore 14
        .cfi_restore 13
        .cfi_restore 12
        .cfi_restore 11
        .cfi_restore 10
        .cfi_restore 9
        .cfi_restore 8
        .cfi_restore 7
        .cfi_restore 6
        .cfi_def_cfa 15, 160

        // Tail call native target.
        br %r1
NESTED_END NDirectImportThunk, _TEXT


#ifdef FEATURE_HIJACK

//------------------------------------------------
// OnHijackTripThread
//
NESTED_ENTRY OnHijackTripThread, _TEXT, NoHandler
// NOT YET IMPLEMENTED
.long 0x81
NESTED_END OnHijackTripThread, _TEXT

#endif // FEATURE_HIJACK

LEAF_ENTRY SinglecastDelegateInvokeStub, _TEXT
    ltr %r2, %r2
    je LOCAL_LABEL(NullObject)

    lg %r1, OFFSETOF__DelegateObject___methodPtr(%r2)
    lg %r2, OFFSETOF__DelegateObject___target(%r2)

    br %r1

LOCAL_LABEL(NullObject):
    lghi %r2, CORINFO_NullReferenceException_ASM
    jg C_FUNC(JIT_InternalThrow)
LEAF_END SinglecastDelegateInvokeStub, _TEXT

#ifdef FEATURE_TIERED_COMPILATION

NESTED_ENTRY OnCallCountThresholdReachedStub, _TEXT, NoHandler
        // Create a full transition block.
        stmg %r2, %r15, 16(%r15)
        .cfi_offset 6, -112
        .cfi_offset 7, -104
        .cfi_offset 8, -96
        .cfi_offset 9, -88
        .cfi_offset 10, -80
        .cfi_offset 11, -72
        .cfi_offset 12, -64
        .cfi_offset 13, -56
        .cfi_offset 14, -48
        .cfi_offset 15, -40
        lay %r15, -160(%r15)
        .cfi_def_cfa_offset 320

        // Save floating-point argument registers.
        std %f0, 288(%r15)
        std %f2, 296(%r15)
        std %f4, 304(%r15)
        std %f6, 312(%r15)

        // Call OnCallCountThresholdReached w/ TransitionBlock *
        // and stub-identifying token (passed by the stub in %r0)
        la %r2, 160(%r15)
        lgr %r3, %r0
        brasl %r14, C_FUNC(OnCallCountThresholdReached)

        // Native target adress now in %r2.
        lgr %r1, %r2

        // Restore floating-point argument registers.
        ld %f0, 288(%r15)
        ld %f2, 296(%r15)
        ld %f4, 304(%r15)
        ld %f6, 312(%r15)

        // Restore integer parameter and call-saved registers.
        lmg %r2, %r15, 176(%r15)
        .cfi_restore 15
        .cfi_restore 14
        .cfi_restore 13
        .cfi_restore 12
        .cfi_restore 11
        .cfi_restore 10
        .cfi_restore 9
        .cfi_restore 8
        .cfi_restore 7
        .cfi_restore 6
        .cfi_def_cfa 15, 160

        // Tail call native target.
        br %r1
NESTED_END OnCallCountThresholdReachedStub, _TEXT

#endif // FEATURE_TIERED_COMPILATION

NESTED_ENTRY InterpreterStubThunk, _TEXT, NoHandler
        // Create a full transition block.
        .cfi_offset 6, -112
        .cfi_offset 7, -104
        .cfi_offset 8, -96
        .cfi_offset 9, -88
        .cfi_offset 10, -80
        .cfi_offset 11, -72
        .cfi_offset 12, -64
        .cfi_offset 13, -56
        .cfi_offset 14, -48
        .cfi_offset 15, -40
        lay %r15, -160(%r15)
        .cfi_def_cfa_offset 320

        basr %r14, %r1

        // Restore call-saved registers.
        lmg %r6, %r15, 208(%r15)
        .cfi_restore 15
        .cfi_restore 14
        .cfi_restore 13
        .cfi_restore 12
        .cfi_restore 11
        .cfi_restore 10
        .cfi_restore 9
        .cfi_restore 8
        .cfi_restore 7
        .cfi_restore 6
        .cfi_def_cfa 15, 160

        // Return.
        br %r14
NESTED_END InterpreterStubThunk, _TEXT
